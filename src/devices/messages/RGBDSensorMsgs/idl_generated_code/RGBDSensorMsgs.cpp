/*
 * SPDX-FileCopyrightText: 2006-2021 Istituto Italiano di Tecnologia (IIT)
 * SPDX-License-Identifier: BSD-3-Clause
 */

// Autogenerated by Thrift Compiler (0.14.1-yarped)
//
// This is an automatically generated file.
// It could get re-generated if the ALLOW_IDL_GENERATION flag is on.

#include <yarp/conf/version.h>
#include <RGBDSensorMsgs.h>
#include <yarp/os/LogComponent.h>
#include <yarp/os/LogStream.h>

#include <yarp/os/idl/WireTypes.h>

#include <algorithm>

namespace
{
    YARP_LOG_COMPONENT(SERVICE_LOG_COMPONENT, "RGBDSensorMsgs")
}

//RGBDSensorMsgs_getRemoteProtocolVersion_helper declaration
class RGBDSensorMsgs_getRemoteProtocolVersion_helper :
public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRemoteProtocolVersion_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    yarp::os::ApplicationNetworkProtocolVersion helper_proto;
};

bool RGBDSensorMsgs_getRemoteProtocolVersion_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeString("getRemoteProtocolVersion")) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRemoteProtocolVersion_helper ::read(yarp::os::ConnectionReader & connection)
 {
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }

    if (!helper_proto.read(connection)) {
        reader.fail();
        return false;
    }
    return true;
}

//ProtocolVersion, client side
yarp::os::ApplicationNetworkProtocolVersion RGBDSensorMsgs::getRemoteProtocolVersion()
 {
    if(!yarp().canWrite()) {
        yError(" Missing server method RGBDSensorMsgs::getRemoteProtocolVersion");
    }
    RGBDSensorMsgs_getRemoteProtocolVersion_helper helper{};
    bool ok = yarp().write(helper, helper);
    if (ok) {
        return helper.helper_proto;}
    else {
        yarp::os::ApplicationNetworkProtocolVersion failureproto;
        return failureproto;}
}

//ProtocolVersion, client side
bool RGBDSensorMsgs::checkProtocolVersion()
 {
        auto locproto = this->getLocalProtocolVersion();
        auto remproto = this->getRemoteProtocolVersion();
        if (remproto.protocol_version != locproto.protocol_version)
        {
            yCError(SERVICE_LOG_COMPONENT) << "Invalid communication protocol.";
            yCError(SERVICE_LOG_COMPONENT) << "Local Protocol Version: " << locproto.toString();
            yCError(SERVICE_LOG_COMPONENT) << "Remote Protocol Version: " << remproto.toString();
            return false;
        }
        return true;
}

//ProtocolVersion, server side
yarp::os::ApplicationNetworkProtocolVersion RGBDSensorMsgs::getLocalProtocolVersion()
{
    yarp::os::ApplicationNetworkProtocolVersion myproto;
    //myproto.protocol_version using default value = 0
    //to change this value add the following line to the .thrift file:
    //const i16 protocol_version = <your_number_here>
    myproto.protocol_version = 0;
    myproto.yarp_major = YARP_VERSION_MAJOR;
    myproto.yarp_minor = YARP_VERSION_MINOR;
    myproto.yarp_patch = YARP_VERSION_PATCH;
    return myproto;
}

// getExtrinsicParamRPC helper class declaration
class RGBDSensorMsgs_getExtrinsicParamRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getExtrinsicParamRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBDMsgs_return_getExtrinsic return_helper{};
    };

    using funcptr_t = IRGBDMsgs_return_getExtrinsic (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getExtrinsicParamRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBDMsgs_return_getExtrinsic RGBDSensorMsgs::getExtrinsicParamRPC()"};
    static constexpr const char* s_help{""};
};

// getLastErrorMsgRPC helper class declaration
class RGBDSensorMsgs_getLastErrorMsgRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getLastErrorMsgRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBDMsgs_return_getLastErrorMsg return_helper{};
    };

    using funcptr_t = IRGBDMsgs_return_getLastErrorMsg (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getLastErrorMsgRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IRGBDMsgs_return_getLastErrorMsg RGBDSensorMsgs::getLastErrorMsgRPC()"};
    static constexpr const char* s_help{""};
};

// getRgbImageRPC helper class declaration
class RGBDSensorMsgs_getRgbImageRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbImageRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBDMsgs_return_getRgbImage return_helper{};
    };

    using funcptr_t = IRGBDMsgs_return_getRgbImage (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbImageRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IRGBDMsgs_return_getRgbImage RGBDSensorMsgs::getRgbImageRPC()"};
    static constexpr const char* s_help{""};
};

// getDepthImageRPC helper class declaration
class RGBDSensorMsgs_getDepthImageRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthImageRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBDMsgs_return_getDepthImage return_helper{};
    };

    using funcptr_t = IRGBDMsgs_return_getDepthImage (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthImageRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IRGBDMsgs_return_getDepthImage RGBDSensorMsgs::getDepthImageRPC()"};
    static constexpr const char* s_help{""};
};

// getImagesRPC helper class declaration
class RGBDSensorMsgs_getImagesRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getImagesRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBDMsgs_return_getImages return_helper{};
    };

    using funcptr_t = IRGBDMsgs_return_getImages (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getImagesRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{5};
    static constexpr const char* s_prototype{"IRGBDMsgs_return_getImages RGBDSensorMsgs::getImagesRPC()"};
    static constexpr const char* s_help{""};
};

// getSensorStatusRPC helper class declaration
class RGBDSensorMsgs_getSensorStatusRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getSensorStatusRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBDMsgs_return_getSensorStatus return_helper{};
    };

    using funcptr_t = IRGBDMsgs_return_getSensorStatus (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getSensorStatusRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBDMsgs_return_getSensorStatus RGBDSensorMsgs::getSensorStatusRPC()"};
    static constexpr const char* s_help{""};
};

// getRgbWidthRPC helper class declaration
class RGBDSensorMsgs_getRgbWidthRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbWidthRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbWidth return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbWidth (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbWidthRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbWidth RGBDSensorMsgs::getRgbWidthRPC()"};
    static constexpr const char* s_help{""};
};

// getRgbHeightRPC helper class declaration
class RGBDSensorMsgs_getRgbHeightRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbHeightRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbHeight return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbHeight (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbHeightRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbHeight RGBDSensorMsgs::getRgbHeightRPC()"};
    static constexpr const char* s_help{""};
};

// getRgbSupportedConfigurationsRPC helper class declaration
class RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbSupportedCfg return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbSupportedCfg (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbSupportedConfigurationsRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbSupportedCfg RGBDSensorMsgs::getRgbSupportedConfigurationsRPC()"};
    static constexpr const char* s_help{""};
};

// getRgbResolutionRPC helper class declaration
class RGBDSensorMsgs_getRgbResolutionRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbResolutionRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbResolution return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbResolution (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbResolutionRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbResolution RGBDSensorMsgs::getRgbResolutionRPC()"};
    static constexpr const char* s_help{""};
};

// setRgbResolutionRPC helper class declaration
class RGBDSensorMsgs_setRgbResolutionRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setRgbResolutionRPC_helper() = default;
    RGBDSensorMsgs_setRgbResolutionRPC_helper(const std::int32_t width, const std::int32_t height);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const std::int32_t width, const std::int32_t height);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t width{0};
        std::int32_t height{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t, const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setRgbResolutionRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setRgbResolutionRPC(const std::int32_t width, const std::int32_t height)"};
    static constexpr const char* s_help{""};
};

// getRgbFOVRPC helper class declaration
class RGBDSensorMsgs_getRgbFOVRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbFOVRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbFOV return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbFOV (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbFOVRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbFOV RGBDSensorMsgs::getRgbFOVRPC()"};
    static constexpr const char* s_help{""};
};

// setRgbFOVRPC helper class declaration
class RGBDSensorMsgs_setRgbFOVRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setRgbFOVRPC_helper() = default;
    RGBDSensorMsgs_setRgbFOVRPC_helper(const double horizontalFov, const double verticalFov);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const double horizontalFov, const double verticalFov);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        double horizontalFov{0.0};
        double verticalFov{0.0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const double, const double);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setRgbFOVRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setRgbFOVRPC(const double horizontalFov, const double verticalFov)"};
    static constexpr const char* s_help{""};
};

// getRgbIntrinsicParamRPC helper class declaration
class RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbIntrinsicParam return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbIntrinsicParam (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbIntrinsicParamRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbIntrinsicParam RGBDSensorMsgs::getRgbIntrinsicParamRPC()"};
    static constexpr const char* s_help{""};
};

// getRgbMirroringRPC helper class declaration
class RGBDSensorMsgs_getRgbMirroringRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getRgbMirroringRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IRGBVisualParamsMsgs_return_getRgbMirroring return_helper{};
    };

    using funcptr_t = IRGBVisualParamsMsgs_return_getRgbMirroring (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getRgbMirroringRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IRGBVisualParamsMsgs_return_getRgbMirroring RGBDSensorMsgs::getRgbMirroringRPC()"};
    static constexpr const char* s_help{""};
};

// setRgbMirroringRPC helper class declaration
class RGBDSensorMsgs_setRgbMirroringRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setRgbMirroringRPC_helper() = default;
    explicit RGBDSensorMsgs_setRgbMirroringRPC_helper(const bool mirror);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const bool mirror);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        bool mirror{false};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const bool);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setRgbMirroringRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setRgbMirroringRPC(const bool mirror)"};
    static constexpr const char* s_help{""};
};

// getDepthWidthRPC helper class declaration
class RGBDSensorMsgs_getDepthWidthRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthWidthRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthWidth return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthWidth (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthWidthRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthWidth RGBDSensorMsgs::getDepthWidthRPC()"};
    static constexpr const char* s_help{""};
};

// getDepthHeightRPC helper class declaration
class RGBDSensorMsgs_getDepthHeightRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthHeightRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthHeight return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthHeight (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthHeightRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthHeight RGBDSensorMsgs::getDepthHeightRPC()"};
    static constexpr const char* s_help{""};
};

// getDepthResolutionRPC helper class declaration
class RGBDSensorMsgs_getDepthResolutionRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthResolutionRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthResolution return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthResolution (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthResolutionRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthResolution RGBDSensorMsgs::getDepthResolutionRPC()"};
    static constexpr const char* s_help{""};
};

// setDepthResolutionRPC helper class declaration
class RGBDSensorMsgs_setDepthResolutionRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setDepthResolutionRPC_helper() = default;
    RGBDSensorMsgs_setDepthResolutionRPC_helper(const std::int32_t width, const std::int32_t height);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const std::int32_t width, const std::int32_t height);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t width{0};
        std::int32_t height{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t, const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setDepthResolutionRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setDepthResolutionRPC(const std::int32_t width, const std::int32_t height)"};
    static constexpr const char* s_help{""};
};

// getDepthFOVRPC helper class declaration
class RGBDSensorMsgs_getDepthFOVRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthFOVRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthFOV return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthFOV (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthFOVRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthFOV RGBDSensorMsgs::getDepthFOVRPC()"};
    static constexpr const char* s_help{""};
};

// setDepthFOVRPC helper class declaration
class RGBDSensorMsgs_setDepthFOVRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setDepthFOVRPC_helper() = default;
    RGBDSensorMsgs_setDepthFOVRPC_helper(const double horizontalFov, const double verticalFov);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const double horizontalFov, const double verticalFov);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        double horizontalFov{0.0};
        double verticalFov{0.0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const double, const double);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setDepthFOVRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setDepthFOVRPC(const double horizontalFov, const double verticalFov)"};
    static constexpr const char* s_help{""};
};

// getDepthAccuracyRPC helper class declaration
class RGBDSensorMsgs_getDepthAccuracyRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthAccuracyRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthAccuracy return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthAccuracy (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthAccuracyRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthAccuracy RGBDSensorMsgs::getDepthAccuracyRPC()"};
    static constexpr const char* s_help{""};
};

// setDepthAccuracyRPC helper class declaration
class RGBDSensorMsgs_setDepthAccuracyRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setDepthAccuracyRPC_helper() = default;
    explicit RGBDSensorMsgs_setDepthAccuracyRPC_helper(const double accuracy);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const double accuracy);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        double accuracy{0.0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const double);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setDepthAccuracyRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setDepthAccuracyRPC(const double accuracy)"};
    static constexpr const char* s_help{""};
};

// getDepthClipPlanesRPC helper class declaration
class RGBDSensorMsgs_getDepthClipPlanesRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthClipPlanesRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthClipPlanes return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthClipPlanes (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthClipPlanesRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthClipPlanes RGBDSensorMsgs::getDepthClipPlanesRPC()"};
    static constexpr const char* s_help{""};
};

// setDepthClipPlanesRPC helper class declaration
class RGBDSensorMsgs_setDepthClipPlanesRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setDepthClipPlanesRPC_helper() = default;
    RGBDSensorMsgs_setDepthClipPlanesRPC_helper(const double nearPlane, const double farPlane);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const double nearPlane, const double farPlane);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        double nearPlane{0.0};
        double farPlane{0.0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const double, const double);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setDepthClipPlanesRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setDepthClipPlanesRPC(const double nearPlane, const double farPlane)"};
    static constexpr const char* s_help{""};
};

// getDepthMirroringRPC helper class declaration
class RGBDSensorMsgs_getDepthMirroringRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthMirroringRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthMirroring return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthMirroring (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthMirroringRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthMirroring RGBDSensorMsgs::getDepthMirroringRPC()"};
    static constexpr const char* s_help{""};
};

// setDepthMirroringRPC helper class declaration
class RGBDSensorMsgs_setDepthMirroringRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setDepthMirroringRPC_helper() = default;
    explicit RGBDSensorMsgs_setDepthMirroringRPC_helper(const bool mirror);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const bool mirror);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        bool mirror{false};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const bool);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setDepthMirroringRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setDepthMirroringRPC(const bool mirror)"};
    static constexpr const char* s_help{""};
};

// getDepthIntrinsicParamRPC helper class declaration
class RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IDepthVisualParamsMsgs_return_getDepthIntrinsicParam return_helper{};
    };

    using funcptr_t = IDepthVisualParamsMsgs_return_getDepthIntrinsicParam (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getDepthIntrinsicParamRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IDepthVisualParamsMsgs_return_getDepthIntrinsicParam RGBDSensorMsgs::getDepthIntrinsicParamRPC()"};
    static constexpr const char* s_help{""};
};

// getCameraDescriptionRPC helper class declaration
class RGBDSensorMsgs_getCameraDescriptionRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getCameraDescriptionRPC_helper() = default;
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_getCameraDescription return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_getCameraDescription (*)();
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getCameraDescriptionRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{1};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_getCameraDescription RGBDSensorMsgs::getCameraDescriptionRPC()"};
    static constexpr const char* s_help{""};
};

// hasFeatureRPC helper class declaration
class RGBDSensorMsgs_hasFeatureRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_hasFeatureRPC_helper() = default;
    explicit RGBDSensorMsgs_hasFeatureRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_hasFeature return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_hasFeature (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"hasFeatureRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_hasFeature RGBDSensorMsgs::hasFeatureRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// setFeature1RPC helper class declaration
class RGBDSensorMsgs_setFeature1RPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setFeature1RPC_helper() = default;
    RGBDSensorMsgs_setFeature1RPC_helper(const std::int32_t feature, const double value);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const std::int32_t feature, const double value);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
        double value{0.0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t, const double);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setFeature1RPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setFeature1RPC(const std::int32_t feature, const double value)"};
    static constexpr const char* s_help{""};
};

// getFeature1RPC helper class declaration
class RGBDSensorMsgs_getFeature1RPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getFeature1RPC_helper() = default;
    explicit RGBDSensorMsgs_getFeature1RPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_getFeature1 return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_getFeature1 (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getFeature1RPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_getFeature1 RGBDSensorMsgs::getFeature1RPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// setFeature2RPC helper class declaration
class RGBDSensorMsgs_setFeature2RPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setFeature2RPC_helper() = default;
    RGBDSensorMsgs_setFeature2RPC_helper(const std::int32_t feature, const double value1, const double value2);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const std::int32_t feature, const double value1, const double value2);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
        double value1{0.0};
        double value2{0.0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t, const double, const double);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setFeature2RPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{4};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setFeature2RPC(const std::int32_t feature, const double value1, const double value2)"};
    static constexpr const char* s_help{""};
};

// getFeature2RPC helper class declaration
class RGBDSensorMsgs_getFeature2RPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getFeature2RPC_helper() = default;
    explicit RGBDSensorMsgs_getFeature2RPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_getFeature2 return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_getFeature2 (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getFeature2RPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{3};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_getFeature2 RGBDSensorMsgs::getFeature2RPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// hasOnOffRPC helper class declaration
class RGBDSensorMsgs_hasOnOffRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_hasOnOffRPC_helper() = default;
    explicit RGBDSensorMsgs_hasOnOffRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_hasOnOff return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_hasOnOff (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"hasOnOffRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_hasOnOff RGBDSensorMsgs::hasOnOffRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// setActiveRPC helper class declaration
class RGBDSensorMsgs_setActiveRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setActiveRPC_helper() = default;
    RGBDSensorMsgs_setActiveRPC_helper(const std::int32_t feature, const bool onoff);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const std::int32_t feature, const bool onoff);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
        bool onoff{false};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t, const bool);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setActiveRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setActiveRPC(const std::int32_t feature, const bool onoff)"};
    static constexpr const char* s_help{""};
};

// getActiveRPC helper class declaration
class RGBDSensorMsgs_getActiveRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getActiveRPC_helper() = default;
    explicit RGBDSensorMsgs_getActiveRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_getActive return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_getActive (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getActiveRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_getActive RGBDSensorMsgs::getActiveRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// hasAutoRPC helper class declaration
class RGBDSensorMsgs_hasAutoRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_hasAutoRPC_helper() = default;
    explicit RGBDSensorMsgs_hasAutoRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_hasAuto return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_hasAuto (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"hasAutoRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_hasAuto RGBDSensorMsgs::hasAutoRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// hasManualRPC helper class declaration
class RGBDSensorMsgs_hasManualRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_hasManualRPC_helper() = default;
    explicit RGBDSensorMsgs_hasManualRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_hasManual return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_hasManual (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"hasManualRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_hasManual RGBDSensorMsgs::hasManualRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// hasOnePushRPC helper class declaration
class RGBDSensorMsgs_hasOnePushRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_hasOnePushRPC_helper() = default;
    explicit RGBDSensorMsgs_hasOnePushRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_hasOnePush return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_hasOnePush (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"hasOnePushRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_hasOnePush RGBDSensorMsgs::hasOnePushRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// setModeRPC helper class declaration
class RGBDSensorMsgs_setModeRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setModeRPC_helper() = default;
    RGBDSensorMsgs_setModeRPC_helper(const std::int32_t feature, const yarp::dev::FeatureMode mode);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        Command(const std::int32_t feature, const yarp::dev::FeatureMode mode);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
        yarp::dev::FeatureMode mode{};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t, const yarp::dev::FeatureMode);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setModeRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{3};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setModeRPC(const std::int32_t feature, const yarp::dev::FeatureMode mode)"};
    static constexpr const char* s_help{""};
};

// getModeRPC helper class declaration
class RGBDSensorMsgs_getModeRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_getModeRPC_helper() = default;
    explicit RGBDSensorMsgs_getModeRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        IFrameGrabberControlMsgs_return_getMode return_helper{};
    };

    using funcptr_t = IFrameGrabberControlMsgs_return_getMode (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"getModeRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{2};
    static constexpr const char* s_prototype{"IFrameGrabberControlMsgs_return_getMode RGBDSensorMsgs::getModeRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// setOnePushRPC helper class declaration
class RGBDSensorMsgs_setOnePushRPC_helper :
        public yarp::os::Portable
{
public:
    RGBDSensorMsgs_setOnePushRPC_helper() = default;
    explicit RGBDSensorMsgs_setOnePushRPC_helper(const std::int32_t feature);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    class Command :
            public yarp::os::idl::WirePortable
    {
    public:
        Command() = default;
        explicit Command(const std::int32_t feature);

        ~Command() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool writeTag(const yarp::os::idl::WireWriter& writer) const;
        bool writeArgs(const yarp::os::idl::WireWriter& writer) const;

        bool read(yarp::os::idl::WireReader& reader) override;
        bool readTag(yarp::os::idl::WireReader& reader);
        bool readArgs(yarp::os::idl::WireReader& reader);

        std::int32_t feature{0};
    };

    class Reply :
            public yarp::os::idl::WirePortable
    {
    public:
        Reply() = default;
        ~Reply() override = default;

        bool write(yarp::os::ConnectionWriter& connection) const override;
        bool read(yarp::os::ConnectionReader& connection) override;

        bool write(const yarp::os::idl::WireWriter& writer) const override;
        bool read(yarp::os::idl::WireReader& reader) override;

        yarp::dev::ReturnValue return_helper{};
    };

    using funcptr_t = yarp::dev::ReturnValue (*)(const std::int32_t);
    void call(RGBDSensorMsgs* ptr);

    Command cmd;
    Reply reply;

    static constexpr const char* s_tag{"setOnePushRPC"};
    static constexpr size_t s_tag_len{1};
    static constexpr size_t s_cmd_len{2};
    static constexpr size_t s_reply_len{1};
    static constexpr const char* s_prototype{"yarp::dev::ReturnValue RGBDSensorMsgs::setOnePushRPC(const std::int32_t feature)"};
    static constexpr const char* s_help{""};
};

// getExtrinsicParamRPC helper class implementation
bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getExtrinsicParamRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getExtrinsicParamRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getExtrinsicParamRPC();
}

// getLastErrorMsgRPC helper class implementation
bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getLastErrorMsgRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getLastErrorMsgRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getLastErrorMsgRPC();
}

// getRgbImageRPC helper class implementation
bool RGBDSensorMsgs_getRgbImageRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbImageRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbImageRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbImageRPC();
}

// getDepthImageRPC helper class implementation
bool RGBDSensorMsgs_getDepthImageRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthImageRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthImageRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthImageRPC();
}

// getImagesRPC helper class implementation
bool RGBDSensorMsgs_getImagesRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getImagesRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getImagesRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getImagesRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getImagesRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getImagesRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getImagesRPC();
}

// getSensorStatusRPC helper class implementation
bool RGBDSensorMsgs_getSensorStatusRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getSensorStatusRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getSensorStatusRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getSensorStatusRPC();
}

// getRgbWidthRPC helper class implementation
bool RGBDSensorMsgs_getRgbWidthRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbWidthRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbWidthRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbWidthRPC();
}

// getRgbHeightRPC helper class implementation
bool RGBDSensorMsgs_getRgbHeightRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbHeightRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbHeightRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbHeightRPC();
}

// getRgbSupportedConfigurationsRPC helper class implementation
bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbSupportedConfigurationsRPC();
}

// getRgbResolutionRPC helper class implementation
bool RGBDSensorMsgs_getRgbResolutionRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbResolutionRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbResolutionRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbResolutionRPC();
}

// setRgbResolutionRPC helper class implementation
RGBDSensorMsgs_setRgbResolutionRPC_helper::RGBDSensorMsgs_setRgbResolutionRPC_helper(const std::int32_t width, const std::int32_t height) :
        cmd{width, height}
{
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::Command(const std::int32_t width, const std::int32_t height) :
        width{width},
        height{height}
{
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(width)) {
        return false;
    }
    if (!writer.writeI32(height)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(width)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(height)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setRgbResolutionRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setRgbResolutionRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setRgbResolutionRPC(cmd.width, cmd.height);
}

// getRgbFOVRPC helper class implementation
bool RGBDSensorMsgs_getRgbFOVRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbFOVRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbFOVRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbFOVRPC();
}

// setRgbFOVRPC helper class implementation
RGBDSensorMsgs_setRgbFOVRPC_helper::RGBDSensorMsgs_setRgbFOVRPC_helper(const double horizontalFov, const double verticalFov) :
        cmd{horizontalFov, verticalFov}
{
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setRgbFOVRPC_helper::Command::Command(const double horizontalFov, const double verticalFov) :
        horizontalFov{horizontalFov},
        verticalFov{verticalFov}
{
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeFloat64(horizontalFov)) {
        return false;
    }
    if (!writer.writeFloat64(verticalFov)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(horizontalFov)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(verticalFov)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setRgbFOVRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setRgbFOVRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setRgbFOVRPC(cmd.horizontalFov, cmd.verticalFov);
}

// getRgbIntrinsicParamRPC helper class implementation
bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbIntrinsicParamRPC();
}

// getRgbMirroringRPC helper class implementation
bool RGBDSensorMsgs_getRgbMirroringRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getRgbMirroringRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getRgbMirroringRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getRgbMirroringRPC();
}

// setRgbMirroringRPC helper class implementation
RGBDSensorMsgs_setRgbMirroringRPC_helper::RGBDSensorMsgs_setRgbMirroringRPC_helper(const bool mirror) :
        cmd{mirror}
{
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::Command(const bool mirror) :
        mirror{mirror}
{
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeBool(mirror)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readBool(mirror)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setRgbMirroringRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setRgbMirroringRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setRgbMirroringRPC(cmd.mirror);
}

// getDepthWidthRPC helper class implementation
bool RGBDSensorMsgs_getDepthWidthRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthWidthRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthWidthRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthWidthRPC();
}

// getDepthHeightRPC helper class implementation
bool RGBDSensorMsgs_getDepthHeightRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthHeightRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthHeightRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthHeightRPC();
}

// getDepthResolutionRPC helper class implementation
bool RGBDSensorMsgs_getDepthResolutionRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthResolutionRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthResolutionRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthResolutionRPC();
}

// setDepthResolutionRPC helper class implementation
RGBDSensorMsgs_setDepthResolutionRPC_helper::RGBDSensorMsgs_setDepthResolutionRPC_helper(const std::int32_t width, const std::int32_t height) :
        cmd{width, height}
{
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::Command(const std::int32_t width, const std::int32_t height) :
        width{width},
        height{height}
{
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(width)) {
        return false;
    }
    if (!writer.writeI32(height)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(width)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(height)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setDepthResolutionRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setDepthResolutionRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setDepthResolutionRPC(cmd.width, cmd.height);
}

// getDepthFOVRPC helper class implementation
bool RGBDSensorMsgs_getDepthFOVRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthFOVRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthFOVRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthFOVRPC();
}

// setDepthFOVRPC helper class implementation
RGBDSensorMsgs_setDepthFOVRPC_helper::RGBDSensorMsgs_setDepthFOVRPC_helper(const double horizontalFov, const double verticalFov) :
        cmd{horizontalFov, verticalFov}
{
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setDepthFOVRPC_helper::Command::Command(const double horizontalFov, const double verticalFov) :
        horizontalFov{horizontalFov},
        verticalFov{verticalFov}
{
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeFloat64(horizontalFov)) {
        return false;
    }
    if (!writer.writeFloat64(verticalFov)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(horizontalFov)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(verticalFov)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setDepthFOVRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setDepthFOVRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setDepthFOVRPC(cmd.horizontalFov, cmd.verticalFov);
}

// getDepthAccuracyRPC helper class implementation
bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthAccuracyRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthAccuracyRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthAccuracyRPC();
}

// setDepthAccuracyRPC helper class implementation
RGBDSensorMsgs_setDepthAccuracyRPC_helper::RGBDSensorMsgs_setDepthAccuracyRPC_helper(const double accuracy) :
        cmd{accuracy}
{
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::Command(const double accuracy) :
        accuracy{accuracy}
{
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeFloat64(accuracy)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(accuracy)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setDepthAccuracyRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setDepthAccuracyRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setDepthAccuracyRPC(cmd.accuracy);
}

// getDepthClipPlanesRPC helper class implementation
bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthClipPlanesRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthClipPlanesRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthClipPlanesRPC();
}

// setDepthClipPlanesRPC helper class implementation
RGBDSensorMsgs_setDepthClipPlanesRPC_helper::RGBDSensorMsgs_setDepthClipPlanesRPC_helper(const double nearPlane, const double farPlane) :
        cmd{nearPlane, farPlane}
{
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::Command(const double nearPlane, const double farPlane) :
        nearPlane{nearPlane},
        farPlane{farPlane}
{
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeFloat64(nearPlane)) {
        return false;
    }
    if (!writer.writeFloat64(farPlane)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(nearPlane)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(farPlane)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setDepthClipPlanesRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setDepthClipPlanesRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setDepthClipPlanesRPC(cmd.nearPlane, cmd.farPlane);
}

// getDepthMirroringRPC helper class implementation
bool RGBDSensorMsgs_getDepthMirroringRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthMirroringRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthMirroringRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthMirroringRPC();
}

// setDepthMirroringRPC helper class implementation
RGBDSensorMsgs_setDepthMirroringRPC_helper::RGBDSensorMsgs_setDepthMirroringRPC_helper(const bool mirror) :
        cmd{mirror}
{
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::Command(const bool mirror) :
        mirror{mirror}
{
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeBool(mirror)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readBool(mirror)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setDepthMirroringRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setDepthMirroringRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setDepthMirroringRPC(cmd.mirror);
}

// getDepthIntrinsicParamRPC helper class implementation
bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getDepthIntrinsicParamRPC();
}

// getCameraDescriptionRPC helper class implementation
bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer [[maybe_unused]]) const
{
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getCameraDescriptionRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getCameraDescriptionRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getCameraDescriptionRPC();
}

// hasFeatureRPC helper class implementation
RGBDSensorMsgs_hasFeatureRPC_helper::RGBDSensorMsgs_hasFeatureRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_hasFeatureRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_hasFeatureRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_hasFeatureRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->hasFeatureRPC(cmd.feature);
}

// setFeature1RPC helper class implementation
RGBDSensorMsgs_setFeature1RPC_helper::RGBDSensorMsgs_setFeature1RPC_helper(const std::int32_t feature, const double value) :
        cmd{feature, value}
{
}

bool RGBDSensorMsgs_setFeature1RPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setFeature1RPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setFeature1RPC_helper::Command::Command(const std::int32_t feature, const double value) :
        feature{feature},
        value{value}
{
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    if (!writer.writeFloat64(value)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(value)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setFeature1RPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setFeature1RPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setFeature1RPC(cmd.feature, cmd.value);
}

// getFeature1RPC helper class implementation
RGBDSensorMsgs_getFeature1RPC_helper::RGBDSensorMsgs_getFeature1RPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_getFeature1RPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getFeature1RPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_getFeature1RPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getFeature1RPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getFeature1RPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getFeature1RPC(cmd.feature);
}

// setFeature2RPC helper class implementation
RGBDSensorMsgs_setFeature2RPC_helper::RGBDSensorMsgs_setFeature2RPC_helper(const std::int32_t feature, const double value1, const double value2) :
        cmd{feature, value1, value2}
{
}

bool RGBDSensorMsgs_setFeature2RPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setFeature2RPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setFeature2RPC_helper::Command::Command(const std::int32_t feature, const double value1, const double value2) :
        feature{feature},
        value1{value1},
        value2{value2}
{
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    if (!writer.writeFloat64(value1)) {
        return false;
    }
    if (!writer.writeFloat64(value2)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(value1)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readFloat64(value2)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setFeature2RPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setFeature2RPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setFeature2RPC(cmd.feature, cmd.value1, cmd.value2);
}

// getFeature2RPC helper class implementation
RGBDSensorMsgs_getFeature2RPC_helper::RGBDSensorMsgs_getFeature2RPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_getFeature2RPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getFeature2RPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_getFeature2RPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getFeature2RPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getFeature2RPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getFeature2RPC(cmd.feature);
}

// hasOnOffRPC helper class implementation
RGBDSensorMsgs_hasOnOffRPC_helper::RGBDSensorMsgs_hasOnOffRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_hasOnOffRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_hasOnOffRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_hasOnOffRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->hasOnOffRPC(cmd.feature);
}

// setActiveRPC helper class implementation
RGBDSensorMsgs_setActiveRPC_helper::RGBDSensorMsgs_setActiveRPC_helper(const std::int32_t feature, const bool onoff) :
        cmd{feature, onoff}
{
}

bool RGBDSensorMsgs_setActiveRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setActiveRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setActiveRPC_helper::Command::Command(const std::int32_t feature, const bool onoff) :
        feature{feature},
        onoff{onoff}
{
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    if (!writer.writeBool(onoff)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readBool(onoff)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setActiveRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setActiveRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setActiveRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setActiveRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setActiveRPC(cmd.feature, cmd.onoff);
}

// getActiveRPC helper class implementation
RGBDSensorMsgs_getActiveRPC_helper::RGBDSensorMsgs_getActiveRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_getActiveRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getActiveRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_getActiveRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getActiveRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getActiveRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getActiveRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getActiveRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getActiveRPC(cmd.feature);
}

// hasAutoRPC helper class implementation
RGBDSensorMsgs_hasAutoRPC_helper::RGBDSensorMsgs_hasAutoRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_hasAutoRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_hasAutoRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_hasAutoRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_hasAutoRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_hasAutoRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->hasAutoRPC(cmd.feature);
}

// hasManualRPC helper class implementation
RGBDSensorMsgs_hasManualRPC_helper::RGBDSensorMsgs_hasManualRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_hasManualRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_hasManualRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_hasManualRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_hasManualRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_hasManualRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_hasManualRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_hasManualRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->hasManualRPC(cmd.feature);
}

// hasOnePushRPC helper class implementation
RGBDSensorMsgs_hasOnePushRPC_helper::RGBDSensorMsgs_hasOnePushRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_hasOnePushRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_hasOnePushRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_hasOnePushRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->hasOnePushRPC(cmd.feature);
}

// setModeRPC helper class implementation
RGBDSensorMsgs_setModeRPC_helper::RGBDSensorMsgs_setModeRPC_helper(const std::int32_t feature, const yarp::dev::FeatureMode mode) :
        cmd{feature, mode}
{
}

bool RGBDSensorMsgs_setModeRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setModeRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setModeRPC_helper::Command::Command(const std::int32_t feature, const yarp::dev::FeatureMode mode) :
        feature{feature},
        mode{mode}
{
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    if (!writer.writeI32(static_cast<int32_t>(mode))) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    int32_t _ecast;
    if (!reader.readI32(_ecast)) {
        reader.fail();
        return false;
    }
    mode = static_cast<yarp::dev::FeatureMode>(_ecast);
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setModeRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setModeRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setModeRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setModeRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setModeRPC(cmd.feature, cmd.mode);
}

// getModeRPC helper class implementation
RGBDSensorMsgs_getModeRPC_helper::RGBDSensorMsgs_getModeRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_getModeRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_getModeRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_getModeRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_getModeRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_getModeRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.writeListHeader(s_reply_len)) {
            return false;
        }
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_getModeRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (!reader.readListReturn()) {
        return false;
    }
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_getModeRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->getModeRPC(cmd.feature);
}

// setOnePushRPC helper class implementation
RGBDSensorMsgs_setOnePushRPC_helper::RGBDSensorMsgs_setOnePushRPC_helper(const std::int32_t feature) :
        cmd{feature}
{
}

bool RGBDSensorMsgs_setOnePushRPC_helper::write(yarp::os::ConnectionWriter& connection) const
{
    return cmd.write(connection);
}

bool RGBDSensorMsgs_setOnePushRPC_helper::read(yarp::os::ConnectionReader& connection)
{
    return reply.read(connection);
}

RGBDSensorMsgs_setOnePushRPC_helper::Command::Command(const std::int32_t feature) :
        feature{feature}
{
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(s_cmd_len)) {
        return false;
    }
    return write(writer);
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }
    return read(reader);
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writeTag(writer)) {
        return false;
    }
    if (!writeArgs(writer)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::writeTag(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeTag(s_tag, 1, s_tag_len)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::writeArgs(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.writeI32(feature)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::read(yarp::os::idl::WireReader& reader)
{
    if (!readTag(reader)) {
        return false;
    }
    if (!readArgs(reader)) {
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::readTag(yarp::os::idl::WireReader& reader)
{
    std::string tag = reader.readTag(s_tag_len);
    if (reader.isError()) {
        return false;
    }
    if (tag != s_tag) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Command::readArgs(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.readI32(feature)) {
        reader.fail();
        return false;
    }
    if (!reader.noMore()) {
        reader.fail();
        return false;
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Reply::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    return write(writer);
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Reply::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    return read(reader);
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Reply::write(const yarp::os::idl::WireWriter& writer) const
{
    if (!writer.isNull()) {
        if (!writer.write(return_helper)) {
            return false;
        }
    }
    return true;
}

bool RGBDSensorMsgs_setOnePushRPC_helper::Reply::read(yarp::os::idl::WireReader& reader)
{
    if (reader.noMore()) {
        reader.fail();
        return false;
    }
    if (!reader.read(return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

void RGBDSensorMsgs_setOnePushRPC_helper::call(RGBDSensorMsgs* ptr)
{
    reply.return_helper = ptr->setOnePushRPC(cmd.feature);
}

// Constructor
RGBDSensorMsgs::RGBDSensorMsgs()
{
    yarp().setOwner(*this);
}

IRGBDMsgs_return_getExtrinsic RGBDSensorMsgs::getExtrinsicParamRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getExtrinsicParamRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getExtrinsicParamRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBDMsgs_return_getExtrinsic{};
}

IRGBDMsgs_return_getLastErrorMsg RGBDSensorMsgs::getLastErrorMsgRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getLastErrorMsgRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getLastErrorMsgRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBDMsgs_return_getLastErrorMsg{};
}

IRGBDMsgs_return_getRgbImage RGBDSensorMsgs::getRgbImageRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbImageRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbImageRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBDMsgs_return_getRgbImage{};
}

IRGBDMsgs_return_getDepthImage RGBDSensorMsgs::getDepthImageRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthImageRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthImageRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBDMsgs_return_getDepthImage{};
}

IRGBDMsgs_return_getImages RGBDSensorMsgs::getImagesRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getImagesRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getImagesRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBDMsgs_return_getImages{};
}

IRGBDMsgs_return_getSensorStatus RGBDSensorMsgs::getSensorStatusRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getSensorStatusRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getSensorStatusRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBDMsgs_return_getSensorStatus{};
}

IRGBVisualParamsMsgs_return_getRgbWidth RGBDSensorMsgs::getRgbWidthRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbWidthRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbWidthRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbWidth{};
}

IRGBVisualParamsMsgs_return_getRgbHeight RGBDSensorMsgs::getRgbHeightRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbHeightRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbHeightRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbHeight{};
}

IRGBVisualParamsMsgs_return_getRgbSupportedCfg RGBDSensorMsgs::getRgbSupportedConfigurationsRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbSupportedCfg{};
}

IRGBVisualParamsMsgs_return_getRgbResolution RGBDSensorMsgs::getRgbResolutionRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbResolutionRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbResolutionRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbResolution{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setRgbResolutionRPC(const std::int32_t width, const std::int32_t height)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setRgbResolutionRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setRgbResolutionRPC_helper helper{width, height};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IRGBVisualParamsMsgs_return_getRgbFOV RGBDSensorMsgs::getRgbFOVRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbFOVRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbFOVRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbFOV{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setRgbFOVRPC(const double horizontalFov, const double verticalFov)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setRgbFOVRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setRgbFOVRPC_helper helper{horizontalFov, verticalFov};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IRGBVisualParamsMsgs_return_getRgbIntrinsicParam RGBDSensorMsgs::getRgbIntrinsicParamRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbIntrinsicParam{};
}

IRGBVisualParamsMsgs_return_getRgbMirroring RGBDSensorMsgs::getRgbMirroringRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getRgbMirroringRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getRgbMirroringRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IRGBVisualParamsMsgs_return_getRgbMirroring{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setRgbMirroringRPC(const bool mirror)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setRgbMirroringRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setRgbMirroringRPC_helper helper{mirror};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IDepthVisualParamsMsgs_return_getDepthWidth RGBDSensorMsgs::getDepthWidthRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthWidthRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthWidthRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthWidth{};
}

IDepthVisualParamsMsgs_return_getDepthHeight RGBDSensorMsgs::getDepthHeightRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthHeightRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthHeightRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthHeight{};
}

IDepthVisualParamsMsgs_return_getDepthResolution RGBDSensorMsgs::getDepthResolutionRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthResolutionRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthResolutionRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthResolution{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setDepthResolutionRPC(const std::int32_t width, const std::int32_t height)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setDepthResolutionRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setDepthResolutionRPC_helper helper{width, height};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IDepthVisualParamsMsgs_return_getDepthFOV RGBDSensorMsgs::getDepthFOVRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthFOVRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthFOVRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthFOV{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setDepthFOVRPC(const double horizontalFov, const double verticalFov)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setDepthFOVRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setDepthFOVRPC_helper helper{horizontalFov, verticalFov};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IDepthVisualParamsMsgs_return_getDepthAccuracy RGBDSensorMsgs::getDepthAccuracyRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthAccuracyRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthAccuracyRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthAccuracy{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setDepthAccuracyRPC(const double accuracy)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setDepthAccuracyRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setDepthAccuracyRPC_helper helper{accuracy};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IDepthVisualParamsMsgs_return_getDepthClipPlanes RGBDSensorMsgs::getDepthClipPlanesRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthClipPlanesRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthClipPlanesRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthClipPlanes{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setDepthClipPlanesRPC(const double nearPlane, const double farPlane)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setDepthClipPlanesRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setDepthClipPlanesRPC_helper helper{nearPlane, farPlane};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IDepthVisualParamsMsgs_return_getDepthMirroring RGBDSensorMsgs::getDepthMirroringRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthMirroringRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthMirroringRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthMirroring{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setDepthMirroringRPC(const bool mirror)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setDepthMirroringRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setDepthMirroringRPC_helper helper{mirror};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IDepthVisualParamsMsgs_return_getDepthIntrinsicParam RGBDSensorMsgs::getDepthIntrinsicParamRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IDepthVisualParamsMsgs_return_getDepthIntrinsicParam{};
}

IFrameGrabberControlMsgs_return_getCameraDescription RGBDSensorMsgs::getCameraDescriptionRPC()
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getCameraDescriptionRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getCameraDescriptionRPC_helper helper{};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_getCameraDescription{};
}

IFrameGrabberControlMsgs_return_hasFeature RGBDSensorMsgs::hasFeatureRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_hasFeatureRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_hasFeatureRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_hasFeature{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setFeature1RPC(const std::int32_t feature, const double value)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setFeature1RPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setFeature1RPC_helper helper{feature, value};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IFrameGrabberControlMsgs_return_getFeature1 RGBDSensorMsgs::getFeature1RPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getFeature1RPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getFeature1RPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_getFeature1{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setFeature2RPC(const std::int32_t feature, const double value1, const double value2)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setFeature2RPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setFeature2RPC_helper helper{feature, value1, value2};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IFrameGrabberControlMsgs_return_getFeature2 RGBDSensorMsgs::getFeature2RPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getFeature2RPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getFeature2RPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_getFeature2{};
}

IFrameGrabberControlMsgs_return_hasOnOff RGBDSensorMsgs::hasOnOffRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_hasOnOffRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_hasOnOffRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_hasOnOff{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setActiveRPC(const std::int32_t feature, const bool onoff)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setActiveRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setActiveRPC_helper helper{feature, onoff};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IFrameGrabberControlMsgs_return_getActive RGBDSensorMsgs::getActiveRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getActiveRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getActiveRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_getActive{};
}

IFrameGrabberControlMsgs_return_hasAuto RGBDSensorMsgs::hasAutoRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_hasAutoRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_hasAutoRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_hasAuto{};
}

IFrameGrabberControlMsgs_return_hasManual RGBDSensorMsgs::hasManualRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_hasManualRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_hasManualRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_hasManual{};
}

IFrameGrabberControlMsgs_return_hasOnePush RGBDSensorMsgs::hasOnePushRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_hasOnePushRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_hasOnePushRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_hasOnePush{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setModeRPC(const std::int32_t feature, const yarp::dev::FeatureMode mode)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setModeRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setModeRPC_helper helper{feature, mode};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

IFrameGrabberControlMsgs_return_getMode RGBDSensorMsgs::getModeRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_getModeRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_getModeRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : IFrameGrabberControlMsgs_return_getMode{};
}

yarp::dev::ReturnValue RGBDSensorMsgs::setOnePushRPC(const std::int32_t feature)
{
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", RGBDSensorMsgs_setOnePushRPC_helper::s_prototype);
    }
    RGBDSensorMsgs_setOnePushRPC_helper helper{feature};
    bool ok = yarp().write(helper, helper);
    return ok ? helper.reply.return_helper : yarp::dev::ReturnValue{};
}

// help method
std::vector<std::string> RGBDSensorMsgs::help(const std::string& functionName)
{
    bool showAll = (functionName == "--all");
    std::vector<std::string> helpString;
    if (showAll) {
        helpString.emplace_back("*** Available commands:");
        helpString.emplace_back(RGBDSensorMsgs_getExtrinsicParamRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getLastErrorMsgRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbImageRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthImageRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getImagesRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getSensorStatusRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbWidthRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbHeightRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbResolutionRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setRgbResolutionRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbFOVRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setRgbFOVRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getRgbMirroringRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setRgbMirroringRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthWidthRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthHeightRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthResolutionRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setDepthResolutionRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthFOVRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setDepthFOVRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthAccuracyRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setDepthAccuracyRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthClipPlanesRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setDepthClipPlanesRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthMirroringRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setDepthMirroringRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getCameraDescriptionRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_hasFeatureRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setFeature1RPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getFeature1RPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setFeature2RPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getFeature2RPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_hasOnOffRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setActiveRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getActiveRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_hasAutoRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_hasManualRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_hasOnePushRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setModeRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_getModeRPC_helper::s_tag);
        helpString.emplace_back(RGBDSensorMsgs_setOnePushRPC_helper::s_tag);
        helpString.emplace_back("help");
    } else {
        if (functionName == RGBDSensorMsgs_getExtrinsicParamRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getExtrinsicParamRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getLastErrorMsgRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getLastErrorMsgRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbImageRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbImageRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthImageRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthImageRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getImagesRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getImagesRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getSensorStatusRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getSensorStatusRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbWidthRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbWidthRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbHeightRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbHeightRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbResolutionRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbResolutionRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setRgbResolutionRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setRgbResolutionRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbFOVRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbFOVRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setRgbFOVRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setRgbFOVRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getRgbMirroringRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getRgbMirroringRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setRgbMirroringRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setRgbMirroringRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthWidthRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthWidthRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthHeightRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthHeightRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthResolutionRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthResolutionRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setDepthResolutionRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setDepthResolutionRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthFOVRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthFOVRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setDepthFOVRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setDepthFOVRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthAccuracyRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthAccuracyRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setDepthAccuracyRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setDepthAccuracyRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthClipPlanesRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthClipPlanesRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setDepthClipPlanesRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setDepthClipPlanesRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthMirroringRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthMirroringRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setDepthMirroringRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setDepthMirroringRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getCameraDescriptionRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getCameraDescriptionRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_hasFeatureRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_hasFeatureRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setFeature1RPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setFeature1RPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getFeature1RPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getFeature1RPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setFeature2RPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setFeature2RPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getFeature2RPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getFeature2RPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_hasOnOffRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_hasOnOffRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setActiveRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setActiveRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getActiveRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getActiveRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_hasAutoRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_hasAutoRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_hasManualRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_hasManualRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_hasOnePushRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_hasOnePushRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setModeRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setModeRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_getModeRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_getModeRPC_helper::s_prototype);
        }
        if (functionName == RGBDSensorMsgs_setOnePushRPC_helper::s_tag) {
            helpString.emplace_back(RGBDSensorMsgs_setOnePushRPC_helper::s_prototype);
        }
        if (functionName == "help") {
            helpString.emplace_back("std::vector<std::string> help(const std::string& functionName = \"--all\")");
            helpString.emplace_back("Return list of available commands, or help message for a specific function");
            helpString.emplace_back("@param functionName name of command for which to get a detailed description. If none or '--all' is provided, print list of available commands");
            helpString.emplace_back("@return list of strings (one string per line)");
        }
    }
    if (helpString.empty()) {
        helpString.emplace_back("Command not found");
    }
    return helpString;
}

// read from ConnectionReader
bool RGBDSensorMsgs::read(yarp::os::ConnectionReader& connection)
{
    constexpr size_t max_tag_len = 1;
    size_t tag_len = 1;

    yarp::os::idl::WireReader reader(connection);
    reader.expectAccept();
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }

    std::string tag = reader.readTag(1);
    bool direct = (tag == "__direct__");
    if (direct) {
        tag = reader.readTag(1);
    }
    while (tag_len <= max_tag_len && !reader.isError()) {
        if(tag == "getRemoteProtocolVersion") {
            if (!reader.noMore()) {
                yError("Reader invalid protocol?! %s:%d - %s", __FILE__, __LINE__, __YFUNCTION__);
                reader.fail();
                return false;
            }

            auto proto = getLocalProtocolVersion();

            yarp::os::idl::WireWriter writer(reader);
           if (!writer.writeListHeader(1)) {
                yWarning("Writer invalid protocol?! %s:%d - %s", __FILE__, __LINE__, __YFUNCTION__);
               return false;}
            if (!writer.write(proto)) {
                yWarning("Writer invalid protocol?! %s:%d - %s", __FILE__, __LINE__, __YFUNCTION__);
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getExtrinsicParamRPC_helper::s_tag) {
            RGBDSensorMsgs_getExtrinsicParamRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getLastErrorMsgRPC_helper::s_tag) {
            RGBDSensorMsgs_getLastErrorMsgRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbImageRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbImageRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthImageRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthImageRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getImagesRPC_helper::s_tag) {
            RGBDSensorMsgs_getImagesRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getSensorStatusRPC_helper::s_tag) {
            RGBDSensorMsgs_getSensorStatusRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbWidthRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbWidthRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbHeightRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbHeightRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbSupportedConfigurationsRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbResolutionRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbResolutionRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setRgbResolutionRPC_helper::s_tag) {
            RGBDSensorMsgs_setRgbResolutionRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbFOVRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbFOVRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setRgbFOVRPC_helper::s_tag) {
            RGBDSensorMsgs_setRgbFOVRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbIntrinsicParamRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getRgbMirroringRPC_helper::s_tag) {
            RGBDSensorMsgs_getRgbMirroringRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setRgbMirroringRPC_helper::s_tag) {
            RGBDSensorMsgs_setRgbMirroringRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthWidthRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthWidthRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthHeightRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthHeightRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthResolutionRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthResolutionRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setDepthResolutionRPC_helper::s_tag) {
            RGBDSensorMsgs_setDepthResolutionRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthFOVRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthFOVRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setDepthFOVRPC_helper::s_tag) {
            RGBDSensorMsgs_setDepthFOVRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthAccuracyRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthAccuracyRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setDepthAccuracyRPC_helper::s_tag) {
            RGBDSensorMsgs_setDepthAccuracyRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthClipPlanesRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthClipPlanesRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setDepthClipPlanesRPC_helper::s_tag) {
            RGBDSensorMsgs_setDepthClipPlanesRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthMirroringRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthMirroringRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setDepthMirroringRPC_helper::s_tag) {
            RGBDSensorMsgs_setDepthMirroringRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper::s_tag) {
            RGBDSensorMsgs_getDepthIntrinsicParamRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getCameraDescriptionRPC_helper::s_tag) {
            RGBDSensorMsgs_getCameraDescriptionRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_hasFeatureRPC_helper::s_tag) {
            RGBDSensorMsgs_hasFeatureRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setFeature1RPC_helper::s_tag) {
            RGBDSensorMsgs_setFeature1RPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getFeature1RPC_helper::s_tag) {
            RGBDSensorMsgs_getFeature1RPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setFeature2RPC_helper::s_tag) {
            RGBDSensorMsgs_setFeature2RPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getFeature2RPC_helper::s_tag) {
            RGBDSensorMsgs_getFeature2RPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_hasOnOffRPC_helper::s_tag) {
            RGBDSensorMsgs_hasOnOffRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setActiveRPC_helper::s_tag) {
            RGBDSensorMsgs_setActiveRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getActiveRPC_helper::s_tag) {
            RGBDSensorMsgs_getActiveRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_hasAutoRPC_helper::s_tag) {
            RGBDSensorMsgs_hasAutoRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_hasManualRPC_helper::s_tag) {
            RGBDSensorMsgs_hasManualRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_hasOnePushRPC_helper::s_tag) {
            RGBDSensorMsgs_hasOnePushRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setModeRPC_helper::s_tag) {
            RGBDSensorMsgs_setModeRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_getModeRPC_helper::s_tag) {
            RGBDSensorMsgs_getModeRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == RGBDSensorMsgs_setOnePushRPC_helper::s_tag) {
            RGBDSensorMsgs_setOnePushRPC_helper helper;
            if (!helper.cmd.readArgs(reader)) {
                return false;
            }

            helper.call(this);

            yarp::os::idl::WireWriter writer(reader);
            if (!helper.reply.write(writer)) {
                return false;
            }
            reader.accept();
            return true;
        }
        if (tag == "help") {
            std::string functionName;
            if (!reader.readString(functionName)) {
                functionName = "--all";
            }
            auto help_strings = help(functionName);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(2)) {
                    return false;
                }
                if (!writer.writeTag("many", 1, 0)) {
                    return false;
                }
                if (!writer.writeListBegin(0, help_strings.size())) {
                    return false;
                }
                for (const auto& help_string : help_strings) {
                    if (!writer.writeString(help_string)) {
                        return false;
                    }
                }
                if (!writer.writeListEnd()) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (reader.noMore()) {
            reader.fail();
            return false;
        }
        std::string next_tag = reader.readTag(1);
        if (next_tag.empty()) {
            break;
        }
        tag.append("_").append(next_tag);
        tag_len = std::count(tag.begin(), tag.end(), '_') + 1;
    }
    return false;
}
